<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star çš„åƒç´ åŠå…¬å®¤</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        #game-container {
            border: 4px solid #e94560;
            image-rendering: pixelated;
        }
        #status-text {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #eee;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 4px;
            max-width: 90%;
            text-align: center;
        }
        .side-panel {
            position: fixed;
            right: 12px;
            width: 360px;
            max-width: 45vw;
            background: rgba(0,0,0,0.75);
            color: #ddd;
            font-size: 11px;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #333;
            white-space: pre-wrap;
            overflow-y: auto;
            max-height: 40vh;
        }
        #gateway-log { top: 12px; }
        #tui-log { top: 55vh; }
        .panel-title { color: #ffd700; font-weight: bold; margin-bottom: 6px; }

        #control-bar {
            position: fixed;
            left: 12px;
            top: 12px;
            display: grid;
            grid-template-columns: repeat(2, 120px);
            gap: 6px;
            background: rgba(0,0,0,0.6);
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #333;
        }
        #control-bar button {
            background: #2c2f3a;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
        }
        #control-bar button:hover { background: #3a3f4f; }

        #scene-card {
            position: fixed;
            left: 50%;
            top: 12px;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.65);
            border: 1px solid #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #scene-icon { font-size: 18px; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="status-text">åŠ è½½ä¸­...</div>
    <div id="scene-card"><div id="scene-icon">ğŸ¦</div><div id="scene-text">å¾…å‘½</div></div>
    <div id="gateway-log" class="side-panel"><div class="panel-title">Gateway Logs</div><div id="gateway-content">åŠ è½½ä¸­...</div></div>
    <div id="tui-log" class="side-panel"><div class="panel-title">TUI Status</div><div id="tui-content">åŠ è½½ä¸­...</div></div>

    <div id="control-bar">
        <button onclick="setState('idle','å¾…å‘½')">å¾…å‘½</button>
        <button onclick="setState('writing','å†™ä½œä¸­')">å†™ä½œ</button>
        <button onclick="setState('researching','æ£€ç´¢ä¸­')">æ£€ç´¢</button>
        <button onclick="setState('executing','æ‰§è¡Œä¸­')">æ‰§è¡Œ</button>
        <button onclick="setState('syncing','åŒæ­¥ä¸­')">åŒæ­¥</button>
        <button onclick="setState('error','æŠ¥è­¦ä¸­')">æŠ¥è­¦</button>
        <button onclick="clearDetail()">æ¸…ç©ºè¯¦æƒ…</button>
        <button onclick="refreshPanels()">åˆ·æ–°é¢æ¿</button>
        <button onclick="togglePanels()">åˆ‡æ¢é¢æ¿</button>
        <button onclick="bubbleNow()">æ°”æ³¡æç¤º</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            pixelArt: true,
            physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
            scene: { preload: preload, create: create, update: update }
        };

        const STATES = {
            idle: { name: 'å¾…å‘½', area: 'breakroom' },
            writing: { name: 'æ•´ç†æ–‡æ¡£', area: 'workdesk' },
            researching: { name: 'æœç´¢ä¿¡æ¯', area: 'workdesk' },
            executing: { name: 'æ‰§è¡Œä»»åŠ¡', area: 'executing' },
            syncing: { name: 'åŒæ­¥å¤‡ä»½', area: 'breakroom' },
            error: { name: 'å‡ºé”™äº†', area: 'alert' }
        };

        const BUBBLE_TEXTS = {
            idle: ['æ‘¸é±¼ä¸­â€¦', 'æœ‰æ²¡æœ‰æ–°ä»»åŠ¡ï¼Ÿ', 'å’–å•¡çœŸå¥½å–', 'ä¼¸ä¸ªæ‡’è…°'],
            writing: ['è¿™ä¸ªè¦è®°ä¸‹æ¥', 'å†™å¾—æ‰‹é…¸', 'å†æ£€æŸ¥ä¸€é', 'å¥½è®°æ€§ä¸å¦‚çƒ‚ç¬”å¤´'],
            researching: ['è®©æˆ‘æœä¸€ä¸‹', 'æ‰¾åˆ°çº¿ç´¢äº†', 'è¿™ä¸ªæœ‰æ„æ€', 'å†æ·±æŒ–ä¸€ç‚¹'],
            executing: ['å†²é¸­ï¼', 'è¿™ä¸ªç®€å•', 'åŠ æ²¹åŠ æ²¹', 'é©¬ä¸Šæå®š'],
            syncing: ['å¤‡ä»½å¤‡ä»½', 'å®‰å…¨ç¬¬ä¸€', 'åŒæ­¥ä¸­â€¦', 'äº‘ç«¯è§'],
            error: ['å•Šå“¦â€¦', 'å‡ºé—®é¢˜äº†', 'è®©æˆ‘çœ‹çœ‹', 'é©¬ä¸Šä¿®å¥½']
        };

        const SCENES = [
            { key: 'email', icon: 'âœ‰ï¸', text: 'å†™é‚®ä»¶' },
            { key: 'code', icon: 'ğŸ’»', text: 'å†™ä»£ç ' },
            { key: 'bug', icon: 'ğŸª²', text: 'ä¿® Bug' },
            { key: 'paper', icon: 'ğŸ“„', text: 'å†™è®ºæ–‡' },
            { key: 'search', icon: 'ğŸ”', text: 'æœç´¢ä¿¡æ¯' },
            { key: 'ticket', icon: 'ğŸ«', text: 'è®¢è½¦ç¥¨' },
            { key: 'calendar', icon: 'ğŸ“…', text: 'æ’æ—¥ç¨‹' },
            { key: 'meeting', icon: 'ğŸ§', text: 'ä¼šè®®ä¸­' },
            { key: 'deploy', icon: 'ğŸš€', text: 'éƒ¨ç½²/å‘å¸ƒ' },
            { key: 'backup', icon: 'ğŸ§ ', text: 'å¤‡ä»½/åŒæ­¥' },
        ];

        let game, star, areas = {}, currentState = 'idle', statusText, lastFetch = 0, lastBlink = 0, lastBubble = 0, targetX = 660, targetY = 170, bubble = null, typewriterText = '', typewriterTarget = '', typewriterIndex = 0, lastTypewriter = 0, lastPanel = 0, lastIdleSwitch = 0, lastTextureSwitch = 0, lastIdleFlip = 0;
        const FETCH_INTERVAL = 2000;
        const BLINK_INTERVAL = 2500;
        const BUBBLE_INTERVAL = 8000;
        const TYPEWRITER_DELAY = 50;
        const PANEL_INTERVAL = 3000;

        function preload() {
            this.load.image('office_bg', '/static/office_bg.png');
            this.load.image('star_idle', '/static/star_idle.png');
            this.load.image('star_writing', '/static/star_writing.png');
            this.load.image('star_researching', '/static/star_researching.png');
            this.load.image('star_executing', '/static/star_executing.png');
            this.load.image('star_syncing', '/static/star_syncing.png');
            this.load.image('star_error', '/static/star_error.png');
        }

        function create() {
            game = this;
            this.add.image(400, 300, 'office_bg');
            areas = {
                breakroom: { x: 200, y: 150 },
                workdesk: { x: 600, y: 150 },
                alert: { x: 100, y: 450 },
                executing: { x: 500, y: 450 }
            };

            // è§’è‰²å›¾ï¼ˆæ ¹æ®çŠ¶æ€åˆ‡æ¢è´´å›¾ï¼‰
            star = game.physics.add.sprite(600, 150, 'star_idle');
            star.setOrigin(0.5);
            star.setScale(0.38);
            star.setAlpha(0.98);

            
            // åŠ åƒç´ é£å°ç‰ŒåŒ¾ï¼šæµ·è¾›å°é¾™è™¾çš„åŠå…¬å®¤
            const plaqueBg = game.add.rectangle(400, 570, 380, 40, 0x5d4037);
            plaqueBg.setStrokeStyle(3, 0x3e2723);
            const plaqueText = game.add.text(400, 570, 'æ‰å°é¹Šçš„åŠå…¬å®¤', {
                font: '18px monospace',
                fill: '#ffd700',
                fontWeight: 'bold',
                stroke: '#000',
                strokeThickness: 2
            }).setOrigin(0.5);
            // ç‰ŒåŒ¾ä¸¤è¾¹åŠ ä¸ªå°è£…é¥°
            game.add.text(230, 570, 'â­', { font: '20px' }).setOrigin(0.5);
            game.add.text(570, 570, 'â­', { font: '20px' }).setOrigin(0.5);

            statusText = document.getElementById('status-text');
            fetchStatus();
        }

        function update(time) {
            if (time - lastFetch > FETCH_INTERVAL) { fetchStatus(); lastFetch = time; }
            if (time - lastPanel > PANEL_INTERVAL) { fetchPanels(); lastPanel = time; }

            // çœ¨çœ¼ï¼ˆå¤–éƒ¨è´´å›¾ä¸æ”¯æŒé—­çœ¼åŠ¨ç”»ï¼Œä¿ç•™è½»å¾®é—ªçƒï¼‰
            if (time - lastBlink > BLINK_INTERVAL) {
                star.setAlpha(0.85);
                lastBlink = time;
                setTimeout(() => { star.setAlpha(0.98); }, 120);
            }

            // å†’æ°”æ³¡
            if (time - lastBubble > BUBBLE_INTERVAL) {
                showBubble();
                lastBubble = time;
            }

            // æ‰“å­—æœºæ•ˆæœ
            if (typewriterIndex < typewriterTarget.length && time - lastTypewriter > TYPEWRITER_DELAY) {
                typewriterText += typewriterTarget[typewriterIndex];
                statusText.textContent = typewriterText;
                typewriterIndex++;
                lastTypewriter = time;
            }

            // ç§»åŠ¨ + å°è¸±æ­¥
            moveStar(time);

        }

        function normalizeState(s) {
            if (!s) return 'idle';
            if (s === 'working') return 'writing';
            if (s === 'run' || s === 'running') return 'executing';
            if (s === 'sync') return 'syncing';
            if (s === 'research') return 'researching';
            return s;
        }

        function fetchStatus() {
            fetch('/status')
                .then(response => response.json())
                .then(data => {
                    const nextState = normalizeState(data.state);
                    const stateInfo = STATES[nextState] || STATES.idle;
                    const changed = nextState !== currentState;
                    currentState = nextState;
                    const nextLine = '[' + stateInfo.name + '] ' + (data.detail || '...');

                    // åœºæ™¯å¡ç‰‡ï¼ˆæ ¹æ® detail/çŠ¶æ€æ¨æ–­ï¼‰
                    const detail = (data.detail || '').toLowerCase();
                    let scene = null;
                    if (detail.includes('é‚®ä»¶') || detail.includes('email')) scene = SCENES[0];
                    else if (detail.includes('ä»£ç ') || detail.includes('code')) scene = SCENES[1];
                    else if (detail.includes('bug')) scene = SCENES[2];
                    else if (detail.includes('è®ºæ–‡') || detail.includes('paper')) scene = SCENES[3];
                    else if (detail.includes('æœç´¢') || detail.includes('æ£€ç´¢') || detail.includes('search')) scene = SCENES[4];
                    else if (detail.includes('è½¦ç¥¨') || detail.includes('æœºç¥¨') || detail.includes('ticket')) scene = SCENES[5];
                    else if (detail.includes('æ—¥ç¨‹') || detail.includes('calendar')) scene = SCENES[6];
                    else if (detail.includes('ä¼šè®®') || detail.includes('meeting')) scene = SCENES[7];
                    else if (detail.includes('éƒ¨ç½²') || detail.includes('å‘å¸ƒ') || detail.includes('deploy')) scene = SCENES[8];
                    else if (detail.includes('åŒæ­¥') || detail.includes('å¤‡ä»½') || detail.includes('backup')) scene = SCENES[9];
                    else {
                        const byState = {
                            idle: { icon: 'â˜•', text: 'å¾…å‘½' },
                            writing: { icon: 'ğŸ“', text: 'æ•´ç†æ–‡æ¡£' },
                            researching: { icon: 'ğŸ”', text: 'æœç´¢ä¿¡æ¯' },
                            executing: { icon: 'âš¡', text: 'æ‰§è¡Œä»»åŠ¡' },
                            syncing: { icon: 'ğŸ§ ', text: 'å¤‡ä»½/åŒæ­¥' },
                            error: { icon: 'ğŸš¨', text: 'ç´§æ€¥å¤„ç†' }
                        };
                        scene = byState[nextState] || { icon: 'ğŸ¦', text: 'å¾…å‘½' };
                    }
                    document.getElementById('scene-icon').textContent = scene.icon;
                    document.getElementById('scene-text').textContent = scene.text;


                    // åˆ‡æ¢è§’è‰²è´´å›¾
                    const texMap = {
                        idle: 'star_idle',
                        writing: 'star_writing',
                        researching: 'star_researching',
                        executing: 'star_executing',
                        syncing: 'star_syncing',
                        error: 'star_error'
                    };
                    const now = Date.now();
                    if (texMap[nextState] && (now - lastTextureSwitch > 500)) {
                        star.setTexture(texMap[nextState]);
                        lastTextureSwitch = now;
                    }

                    if (changed) {
                        typewriterTarget = nextLine;
                        typewriterText = '';
                        typewriterIndex = 0;
                        const targetArea = areas[stateInfo.area] || areas.breakroom;
                        targetX = targetArea.x + (Math.random() - 0.5) * 40;
                        targetY = targetArea.y + (Math.random() - 0.5) * 40;
                    } else {
                        if (!typewriterTarget || typewriterTarget !== nextLine) {
                            typewriterTarget = nextLine;
                            typewriterText = '';
                            typewriterIndex = 0;
                        }
                    }
                })
                .catch(error => {
                    typewriterTarget = 'è¿æ¥å¤±è´¥ï¼Œæ­£åœ¨é‡è¯•...';
                    typewriterText = '';
                    typewriterIndex = 0;
                });
        }

        function fetchPanels() {
            fetch('/gateway_logs')
                .then(r => r.json())
                .then(d => { document.getElementById('gateway-content').textContent = d.text || ''; })
                .catch(() => { document.getElementById('gateway-content').textContent = 'log fetch failed'; });
            fetch('/tui')
                .then(r => r.json())
                .then(d => { document.getElementById('tui-content').textContent = d.text || ''; })
                .catch(() => { document.getElementById('tui-content').textContent = 'tui fetch failed'; });
        }

        function setState(state, detail) {
            fetch('/set_state', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ state, detail })
            }).then(() => fetchStatus());
        }

        function clearDetail() {
            fetch('/set_state', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ detail: '' })
            }).then(() => fetchStatus());
        }

        function refreshPanels() {
            fetchPanels();
        }

        function togglePanels() {
            const g = document.getElementById('gateway-log');
            const t = document.getElementById('tui-log');
            const hidden = g.style.display === 'none';
            g.style.display = hidden ? 'block' : 'none';
            t.style.display = hidden ? 'block' : 'none';
        }

        function bubbleNow() {
            showBubble();
        }

        function moveStar(time) {
            const stateInfo = STATES[currentState] || STATES.idle;
            const baseTarget = areas[stateInfo.area] || areas.breakroom;
            if (Math.random() < 0.006) {
                targetX = baseTarget.x + (Math.random() - 0.5) * 40;
                targetY = baseTarget.y + (Math.random() - 0.5) * 40;
            }
            const dx = targetX - star.x;
            const dy = targetY - star.y;
            const dist = Math.hypot(dx, dy);
            const wobble = Math.sin(time / 200) * 0.8;
            // é€Ÿåº¦æŒ‰çŠ¶æ€
            let speed = 1.2;
            if (currentState === 'idle') speed = 0.6;
            if (currentState === 'executing') speed = 1.6;
            if (currentState === 'error') speed = 2.2;

            const moving = dist > 3;
            if (moving) {
                star.x += Math.sign(dx) * speed;
                star.y += Math.sign(dy) * speed;
            }

            // æ˜¯å¦ä»åœ¨åŒºåŸŸä¸­å¿ƒé™„è¿‘
            const inArea = dist < 25;

            if (moving && !inArea) {
                // æˆ¿é—´é—´ç§»åŠ¨ï¼šç”¨ walking
                if (currentState !== 'error') {
                    const now = Date.now();
                    if (now - lastTextureSwitch > 500) {
                        star.setTexture('star_researching');
                        lastTextureSwitch = now;
                    }
                }
            } else {
                // åŒºåŸŸå†…ï¼šæŒ‰çŠ¶æ€è´´å›¾
                const texMap = {
                    idle: 'star_idle',
                    writing: 'star_writing',
                    researching: 'star_researching',
                    executing: 'star_executing',
                    syncing: 'star_syncing',
                    error: 'star_error'
                };
                const now = Date.now();
                if (texMap[currentState] && (now - lastTextureSwitch > 500)) {
                    star.setTexture(texMap[currentState]);
                    lastTextureSwitch = now;
                }
            }

            // idle å¶å°”åˆ‡å› resting åŠ¨ä½œ
            if (currentState === 'idle' && time - lastIdleSwitch > 5000) {
                if (Math.random() < 0.4) star.setTexture('star_idle');
                lastIdleSwitch = time;
            }

            if (moving) {
                // å§‹ç»ˆæœç§»åŠ¨æ–¹å‘é•œåƒï¼ˆèŠ‚æµ 0.5sï¼‰
                const now = Date.now();
                if (now - lastTextureSwitch > 500) {
                    star.setFlipX(dx < 0);
                }
                star.setY(star.y + wobble);
            } else {
                const now = Date.now();
                if (currentState === 'idle') {
                    // idle æ¯3ç§’é•œåƒä¸€æ¬¡
                    if (now - lastIdleFlip > 3000) {
                        star.setFlipX(!star.flipX);
                        lastIdleFlip = now;
                    }
                } else {
                    // åŒºåŸŸå†…æ‰§è¡Œä»»åŠ¡ï¼šæ¯2ç§’é•œåƒä¸€æ¬¡
                    if (now - lastIdleFlip > 2000) {
                        star.setFlipX(!star.flipX);
                        lastIdleFlip = now;
                    }
                }
            }
        }

        function showBubble() {
            if (bubble) { bubble.destroy(); bubble = null; }
            const texts = BUBBLE_TEXTS[currentState] || BUBBLE_TEXTS.idle;
            const text = texts[Math.floor(Math.random() * texts.length)];
            const bg = game.add.rectangle(star.x, star.y - 45, text.length * 10 + 20, 28, 0xffffff, 0.95);
            bg.setStrokeStyle(2, 0x000000);
            const txt = game.add.text(star.x, star.y - 45, text, { font: '12px monospace', fill: '#000', align: 'center' }).setOrigin(0.5);
            bubble = game.add.container(0, 0, [bg, txt]);
            bubble.setDepth(100);
            setTimeout(() => { if (bubble) { bubble.destroy(); bubble = null; } }, 3000);
        }

        new Phaser.Game(config);
    </script>
</body>
</html>
